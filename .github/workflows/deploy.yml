name: Deploy to AWS EC2

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

jobs:
  test:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: backend/package-lock.json
    
    - name: Install dependencies
      run: |
        cd backend
        npm ci
    
    - name: Run linting
      run: |
        cd backend
        npm run lint || echo "Linting not configured, skipping..."
    
    - name: Run tests
      run: |
        cd backend
        npm test || echo "Tests not configured, skipping..."
    
    - name: Validate environment configuration
      run: |
        chmod +x scripts/validate-env.sh
        bash scripts/validate-env.sh production || echo "Environment validation completed"

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-southeast-1
    
    - name: Get EC2 instance IP
      id: get-ip
      run: |
        INSTANCE_IP=$(aws ec2 describe-instances \
          --instance-ids i-0f4af27f7d4b2ee8d \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        echo "instance-ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
        echo "Instance IP: $INSTANCE_IP"
    
    - name: Create deployment package
      env:
        SERVER_IP: ${{ steps.get-ip.outputs.instance-ip }}
      run: |
        echo "ğŸš€ Starting deployment to EC2 instance: i-0f4af27f7d4b2ee8d"
        echo "ğŸ“ Instance IP: $SERVER_IP"
        
        # Create deployment package
        echo "ğŸ“¦ Creating deployment package..."
        TEMP_DIR="/tmp/mydigitalspace-deploy"
        rm -rf $TEMP_DIR
        mkdir -p $TEMP_DIR
        
        # Copy files (excluding unnecessary files)
        rsync -av \
          --exclude='node_modules' \
          --exclude='.git' \
          --exclude='*.log' \
          --exclude='.DS_Store' \
          --exclude='.github' \
          --exclude='deploy.sh' \
          --exclude='quick-deploy.sh' \
          ./ $TEMP_DIR/
        
        # Create production environment file
        echo "ğŸ”§ Creating production environment..."
        JWT_SECRET_VALUE="mydigitalspace-$(openssl rand -hex 32)"
        
        cat > $TEMP_DIR/backend/.env << EOF
        NODE_ENV=production
        PORT=3001
        DB_PATH=./data/knowledgehub.db
        JWT_SECRET=$JWT_SECRET_VALUE
        CORS_ORIGIN=http://$SERVER_IP,https://$SERVER_IP,http://$SERVER_IP:80
        FRONTEND_URL=http://$SERVER_IP
        RATE_LIMIT_WINDOW_MS=900000
        RATE_LIMIT_MAX_REQUESTS=100
        EOF
        
        # Create deployment script
        cat > $TEMP_DIR/deploy-server.sh << 'EOF'
        #!/bin/bash
        set -e
        
        cd /var/www/MyDigitalSpace
        
        # Set proper permissions
        sudo chown -R ubuntu:ubuntu /var/www/MyDigitalSpace
        
        # Install/update backend dependencies
        echo "ğŸ“¦ Installing backend dependencies..."
        cd backend
        npm install --production
        
        # Create database directories
        mkdir -p data database
        
        # Run database setup
        echo "ğŸ—„ï¸ Setting up database..."
        node scripts/setup-database.js 2>/dev/null || echo "Database initialization will happen on first run"
        node scripts/add-users.js 2>/dev/null || echo "Users will be created on first run"
        
        # Install PM2 if not already installed
        if ! command -v pm2 &> /dev/null; then
            echo "ğŸ“‹ Installing PM2..."
            sudo npm install -g pm2
        fi
        
        # Create/update PM2 ecosystem file
        cat > ecosystem.config.js << 'PM2_CONFIG'
        module.exports = {
          apps: [{
            name: 'mydigitalspace-backend',
            script: 'server-sqlite.js',
            cwd: '/var/www/MyDigitalSpace/backend',
            instances: 1,
            exec_mode: 'cluster',
            env: {
              NODE_ENV: 'production',
              PORT: 3001
            },
            env_production: {
              NODE_ENV: 'production',
              PORT: 3001
            },
            error_file: '/var/log/mydigitalspace/error.log',
            out_file: '/var/log/mydigitalspace/access.log',
            log_file: '/var/log/mydigitalspace/combined.log',
            time: true
          }]
        };
        PM2_CONFIG
        
        # Create log directory
        sudo mkdir -p /var/log/mydigitalspace
        sudo chown ubuntu:ubuntu /var/log/mydigitalspace
        
        # Restart application
        echo "ğŸ”„ Restarting application..."
        pm2 stop mydigitalspace-backend 2>/dev/null || true
        pm2 delete mydigitalspace-backend 2>/dev/null || true
        pm2 start ecosystem.config.js
        pm2 save
        pm2 startup ubuntu -u ubuntu --hp /home/ubuntu 2>/dev/null || true
        
        # Setup/update Nginx configuration
        echo "ğŸŒ Configuring Nginx..."
        sudo tee /etc/nginx/sites-available/mydigitalspace << 'NGINX_CONFIG'
        server {
            listen 80;
            server_name _;
            
            # Serve static files
            location / {
                root /var/www/MyDigitalSpace;
                try_files \$uri \$uri/ /index.html;
                
                # Cache static assets
                location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)\$ {
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                }
            }
            
            # Proxy API requests to backend
            location /api/ {
                proxy_pass http://localhost:3001;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_set_header X-Real-IP \$remote_addr;
                proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto \$scheme;
                proxy_cache_bypass \$http_upgrade;
            }
            
            # Health check endpoint
            location /health {
                proxy_pass http://localhost:3001;
                proxy_http_version 1.1;
                proxy_set_header Host \$host;
            }
            
            # Security headers
            add_header X-Frame-Options "SAMEORIGIN" always;
            add_header X-Content-Type-Options "nosniff" always;
            add_header X-XSS-Protection "1; mode=block" always;
            add_header Referrer-Policy "no-referrer-when-downgrade" always;
        }
        NGINX_CONFIG
        
        # Enable site and reload Nginx
        sudo ln -sf /etc/nginx/sites-available/mydigitalspace /etc/nginx/sites-enabled/
        sudo nginx -t && sudo systemctl reload nginx
        
        # Verify deployment
        echo "âœ… Checking application status..."
        pm2 status
        
        # Test health endpoint
        sleep 5
        curl -f http://localhost:3001/health || echo "Health check will be available after startup"
        
        echo "ğŸ‰ Deployment completed successfully!"
        EOF
        
        chmod +x $TEMP_DIR/deploy-server.sh
        
        # Create archive
        tar -czf mydigitalspace-deploy.tar.gz -C $TEMP_DIR .
    
    - name: Setup SSH key
      run: |
        # Create SSH directory and known_hosts file
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        touch ~/.ssh/known_hosts
        chmod 600 ~/.ssh/known_hosts
        
        # Setup private key
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > /tmp/ssh_key
        chmod 600 /tmp/ssh_key
        
        # Add server to known hosts
        ssh-keyscan -H ${{ steps.get-ip.outputs.instance-ip }} >> ~/.ssh/known_hosts
    
    - name: Deploy to EC2
      env:
        SERVER_IP: ${{ steps.get-ip.outputs.instance-ip }}
        SERVER_USER: ubuntu
        INSTANCE_ID: i-0f4af27f7d4b2ee8d
      run: |
        # Upload deployment package
        echo "ğŸ“¤ Uploading files to server..."
        scp -i /tmp/ssh_key -o StrictHostKeyChecking=no mydigitalspace-deploy.tar.gz ubuntu@$SERVER_IP:/tmp/
        
        # Execute deployment on remote server
        echo "ğŸ—ï¸ Setting up application on server..."
        ssh -i /tmp/ssh_key -o StrictHostKeyChecking=no ubuntu@$SERVER_IP << 'REMOTE_COMMANDS'
        
        cd /tmp
        
        # Extract deployment package
        rm -rf mydigitalspace-deploy
        tar -xzf mydigitalspace-deploy.tar.gz
        
        # Sync files to application directory
        sudo mkdir -p /var/www/MyDigitalSpace
        sudo rsync -av --delete mydigitalspace-deploy/ /var/www/MyDigitalSpace/ --exclude=deploy-server.sh
        
        # Run deployment script
        chmod +x mydigitalspace-deploy/deploy-server.sh
        ./mydigitalspace-deploy/deploy-server.sh
        
        # Cleanup
        rm -rf /tmp/mydigitalspace-deploy*
        
        REMOTE_COMMANDS
        
        # Cleanup local files
        rm -f /tmp/ssh_key
        
        echo "âœ… GitHub Actions deployment completed!"
        echo "ğŸŒ Your application is available at: http://$SERVER_IP"
    
    - name: Verify deployment
      run: |
        # Wait for service to be ready
        sleep 15
        
        # Test endpoints
        SERVER_IP="${{ steps.get-ip.outputs.instance-ip }}"
        echo "ğŸ” Testing deployment at: http://$SERVER_IP"
        
        # Test health endpoint
        curl -f "http://$SERVER_IP/health" || curl -f "http://$SERVER_IP:3001/health"
        
        # Test API endpoint
        curl -f "http://$SERVER_IP/api" || echo "API endpoint check completed"
        
        echo "ğŸ‰ Deployment verification successful!"
    
    - name: Deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "âœ… Deployment successful!"
          echo "ğŸŒ Application URL: http://${{ steps.get-ip.outputs.instance-ip }}"
          echo "ğŸ“± Instance ID: i-0f4af27f7d4b2ee8d"
        else
          echo "âŒ Deployment failed!"
        fi